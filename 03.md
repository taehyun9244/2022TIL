
# 03/06
#### @MappedSuperclass 
- 이것은 생성 수정일자를 모든 엔티티에서 공통으로 가져가야 되므로 추가, 또한 BaseEntity임을 알리기위해서 사용
#### @EntityListeners(AuditingEntityListener.class)
- 자동적으로 시간을 적용해주며, BaseEntity를 상속받은 곳에서는 AuditingEntityListener를 지정 불필요

---

# 03/07
#### JUnit5
: 자바 단위 테스트를 위한 테스팅 프레임워크

#### Assert
: 자바 테스트를 돕기 위해 다양한 문법을 지원하는 라이브러리

---

# 03/08
#### dependencies
- 라이브러리를 추가할 때, build.grale에 들어가 dependencies를 오른쪽 클릭하고 generate에서 추가가능

#### 객체의 생성과 초기화를 분리하자
- 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가지고 있습니다. 이렇게 생성된 값들을 활용해서 외부와 연결하는 등 무거운 작업을 수행합니다. 그렇기 때문에, 생성장 안에서 무거운 초기화 적업을 하는것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관섬에서 좋습니다. 물론 가벼운 작업은 생성자에서 한번에 처리해되 좋을 수 있습니다.

---

# 03/09
- 부모클래스가 자식클래스에게 상속을 할 때, 하위 클래스인 자식 클래스에 super 키워드는 부모 클래스를 의미한다. 여기에 ()붙이면 부모 클래스의 생성자를 의미하게 된다. 이렇게 하면 부모 클래스의 기본 생성자가 없어져도 오류가 발생하지 않는다. 하위 클래스의 생성자에서 super를 사용할 때 주의할 점은 super가 가장 먼저 나타나야 한다는 점이다. 
```
class dog extends animal {
    public wang(int a, int b) {
        super(a, b);
    }
```

---

# 03/10
- test코드 작성시 @Disabled 어노테이션을 붙이면, 테스트 동작을 하지 않는다.
- 테스트 코드를 먼저 작성 한 후에 시작하자. 
- 너무 복잡해져서 테스트 코드 작성이 힘들어진다. -> 테스트코드를 먼저 작성하고 난 후, 개발을 시작하면 아직 어렵다. 계속 전부 빨간줄이되어서 심적인 압박감이 엄첨나다.


---

# 03/14
- @RequestParam, @ModelAttribute(객체의 setter설정 필수)는 생각 가능, @PathVariable, @RequestBody는 생략 불가

---

# 03/22
## Array vs Linked list
- Array는 메모리 상에서 연속적으로 데이터를 저장하는 자료구조 입니다. Linked List는 메모리상에서는 연속적이지 않지만, 각각의 원소가 다음 원소의 메모리 주소값을 저장해 놓음으로써 논리적 연속성을 유지합니다.
- 그래서 각 operation의 시간복잡도가 다릅니다. 데이터 조회는 Array의 경우 $O(1)$, Linked list는 $O(n)$의 시간복잡도를 갖습니다. 삽입/삭제는 Array $O(n)$, Linked list $O(1)$의 시간복잡도를 갖습니다.
따라서 얼마만큼의 데이터를 저장할지 미리 알고있고, 조회를 많이 한다면 Array를 사용하는 것이 좋습니다. 반면에 몇개의 데이터를 저장할 지 불확실하고 삽입 삭제가 잦다면 Linked list를 - 사용하는 것이 유리합니다.

---
# 03/23
## Queue vs priority queue
- Queue 자료구조는 시간 순서상 먼저 집어 넣은 데이터가 먼저 나오는 선입선출 FIFO(First In First Out) 구조로 저장하는 형식입니다. 이와 다르게 우선순위큐(priority queue)는 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나옵니다. 
