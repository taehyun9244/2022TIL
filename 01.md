# 01/01

### 추상 클래스와 interface의 차이점
- 클래스안에는 크게 일반 클래스와 추상클래스로 나뉘게 됩니다. 추상클래스 안에는 "추상 메소드"가 하나 이상 포함되거나, abstract로 정의된 경우를 말합니다. 반면 interface는 모든 메서드가 추상 메서드인 경우를 말합니다. 추상 클래스는 사용하고자 하는 추상클래스를 상속받아서 기능을 확장 또는 이용합니다. interface는 함수만 존재함으로, 그 함수의 구현을 강제하기 위해서 사용됩니다.
---

# 01/02

### Lombok
- lombok는 java라이브러리로 반복되는 getter, setter, toStriong 등의 메서드 작성 코드를 줄여주는 라이브러리 입니다. lombok는 복잡하고 반복되는 코드가 줄어듦으로써, 코드의 가독성을 높일 수 있고, 코딩 생산성 또한 높일 수 있습니다. 하지만, lombok의 @Date, @ToString으로 자동 생성되는 메서드는 순환참조 또는 무한 재귀호출 문제로 인해 StackOverflowError가 발생할 수 있기에, 단지 lombok이 편하다는 이유로 아무생각없이 사용한다면, 여러가지 문제가 발생할 수 있습니다.

---

# 01/03

### NoUniqueBeanDefinitionException
- 하나의 bean만 기대했지만, 2개의 bean이 등록 되었을 떄, 뜨는 오류입니다.

---

# 01/04

### NoUniqueBeanDefinitionException의 해결방법(2개의 bean이 등록)

1. @Autowired의 필드명 매칭
- 필드 이름, 파라미터 이름으로 bean이름을 추가 매칭합니다.
ex)
```
@Autowired
private DiscountPolicy discountPolicy
```
에서
```
@Autowired
private DiscountPolicy rateDiscountPolicy
```
타입매칭 시도 후 그 결과에 여러 bean이 존재 할 경우 추가로 동작합니다.
2. @Qualifier 빈 이름 매칭
- 추가 구분자를 붙여주는 방법입니다. bean이름을 변경하지 않습니다.
ex)
```
@Qualifier("mainDiscountPolicy")
public class RateDiscountPolicy implements DiscountPolicy {}
```
와 함께 생성장에도
```
@Autowired
public OrderServiceImpl(MemberRepository memberRepository, @Qualifier("mainDiscountPolicy") DiscountPolicy
discountPolicy)
```
작성해 줘야 됩니다.
- @Qualifier 로 주입할 때 @Qualifier("mainDiscountPolicy")를 찾지 못한다면, mainDiscountPolicy의 이름을 spring bean에서 추가로 찾습니다. 그렇기 떄문에, @Qualifier는 @Qualifier를 찾는 용도로만 사용하는 것이 명확하고 좋습니다.

3. @Primary 사용
- @Autowired 시에 여러 빈이 매칭되면 @Primary 가 우선권을 가지고 있습니다.
ex)
```
@Component
@Primary
public class RateDiscountPolicy implements DiscountPolicy {}
```
- @Primary와 @Qualifier의 우선순위는 @Qualifier에 있습니다. 그 이유는, 수동적으로 세세하게 작성해주기 때문에, 우선권을 가지게 됩니다.

---

# 01/05
